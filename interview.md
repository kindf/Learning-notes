#### 语言层面  
> ##### const的作用  
> &emsp; 1.const修饰全局变量：表示全局变量为常量，其值不能被修改  
> &emsp; 2.const修饰局部变量：表示局部变量为常量，其值不能被修改  
> &emsp; 3.const修饰指针：const在指针左方表示该指针指向常量，const在指针右方表示修饰指针，指针的值为常量  
> &emsp; 4.const修饰形参：表示传入的值为常量，不能被改变  
> &emsp; 5.const修饰类的成员变量：该成员变量需要在构造函数初始化列表中初始化  
> &emsp; 6.const修饰函数：表示该函数的返回值为常量  
> &emsp; 7.const修饰类的成员函数（右方）：表示该成员函数不修改成员变量的值  
>
> ##### static关键字作用
> &emsp; 1.修饰局部变量：表示该变量局部可见，全局存在  
> &emsp; 2.修饰全局变量：表示该全局变量可见性限制在本编译单元中，而未加static的全局变量具有全局可见性  
> &emsp; 3.修饰类的成员变量：表示该成员变量属于整个类而非某个类的对象  
> &emsp; 4.修饰类的成员函数：表示该成员函数属于整个类，故其没有this指针，只能访问类的静态数据和静态函数  
> &emsp; 5.保持变量内容的持久：
> &emsp; 6.static修饰的变量储存在静态数据区，在程序运行前就会完成唯一一次初始化，默认初始化为0  
>
> ##### extern关键字作用  
> &emsp; 1.extern可以置于变量和函数之前，表示变量或函数的定义在别的文件  
> &emsp; 2.extern "c"：在c++文件中调用c方式编译   
> ##### malloc的实现方案  
> &emsp; 1.malloc实质上是将可用的内存块连接成一个空闲链表  
> &emsp; 2.调用malloc()实际上是在这个空闲链表寻找足够大小的内存块，将内存块一分为二，其中一块分配给用户，另外的放回链表中  
> &emsp; 3.调用free()是将用户释放的内存块放回到空闲链表中  
> &emsp; 4.当malloc()没有找到适当大小的内存块时，malloc函数会请求延时并开始整理空闲链表的内存块  
> &emsp; 5.当申请内存小于128k时，malloc实际上时调用brk系统调用将_edata指针往高地址推，从而分配内存  
> &emsp; 6.当申请内存大于128k时，调用mmap系统调用在堆与栈之间（称为文件映射区域）寻找空闲内存进行分配，并初始化为0  
> &emsp; 7.该两种方式分配的都是虚拟内存，在第一次访问虚拟地址空间时会发生缺页中断，操作系统此时才会分配物理内存并更新页表，建立映射关系  
>
> ##### 一个c++程序从文本到可执行文件的过程  
>
> &emsp; 1.预处理：删除并替换所有的#define，处理条件编译指令（"#if", "#endif", "else"等），处理"#include"预编译指令，删除注释等等，生成.ii文件  
> &emsp; 2.编译：词法分析，语法分析，语义分析，目标代码生成，目标代码优化，生成.s文件   
> &emsp; 3.汇编：将编译生成的文件转化为机器码，生成目标文件（.o文件或.obj文件）  
> &emsp; 4.链接：将多个目标文件和所需要的库连接形成可执行文件，生成.exe或.out文件   
>
> ##### 析构函数能否抛异常，为什么  
>
>  &emsp; 1.c++标准指明析构函数不能，也不应该抛出异常。通常异常发生时，c++机制会调用析构函数释放异常对象的资源  
>
> &emsp; 2.若在析构函数中抛异常，则异常点之后的程序就不会执行，导致在异常点之后的资源释放不会执行，造成资源泄露  
>
> &emsp; 3.通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题  
>
> ##### sdfds
>
> 

#### 操作系统层面

#### 网络编程层面

#### 数据库层面

#### 多线程多进程层面
