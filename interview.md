#### 语言层面  
> ##### const的作用  
> &emsp; 1.const修饰全局变量：表示全局变量为常量，其值不能被修改  
> &emsp; 2.const修饰局部变量：表示局部变量为常量，其值不能被修改  
> &emsp; 3.const修饰指针：const在指针左方表示该指针指向常量，const在指针右方表示修饰指针，指针的值为常量  
> &emsp; 4.const修饰形参：表示传入的值为常量，不能被改变  
> &emsp; 5.const修饰类的成员变量：该成员变量需要在构造函数初始化列表中初始化  
> &emsp; 6.const修饰函数：表示该函数的返回值为常量  
> &emsp; 7.const修饰类的成员函数（右方）：表示该成员函数不修改成员变量的值  
>
> ##### static关键字作用
> &emsp; 1.修饰局部变量：表示该变量局部可见，全局存在  
> &emsp; 2.修饰全局变量：表示该全局变量可见性限制在本编译单元中，而未加static的全局变量具有全局可见性  
> &emsp; 3.修饰类的成员变量：表示该成员变量属于整个类而非某个类的对象  
> &emsp; 4.修饰类的成员函数：表示该成员函数属于整个类，故其没有this指针，只能访问类的静态数据和静态函数  
> &emsp; 5.保持变量内容的持久：
> &emsp; 6.static修饰的变量储存在静态数据区，在程序运行前就会完成唯一一次初始化，默认初始化为0  
>
> ##### extern关键字作用  
> &emsp; 1.extern可以置于变量和函数之前，表示变量或函数的定义在别的文件  
> &emsp; 2.extern "c"：在c++文件中调用c方式编译   
> ##### malloc的实现方案  
> &emsp; 1.malloc实质上是将可用的内存块连接成一个空闲链表  
> &emsp; 2.调用malloc()实际上是在这个空闲链表寻找足够大小的内存块，将内存块一分为二，其中一块分配给用户，另外的放回链表中  
> &emsp; 3.调用free()是将用户释放的内存块放回到空闲链表中  
> &emsp; 4.当malloc()没有找到适当大小的内存块时，malloc函数会请求延时并开始整理空闲链表的内存块  
> &emsp; 5.当申请内存小于128k时，malloc实际上时调用brk系统调用将_edata指针往高地址推，从而分配内存  
> &emsp; 6.当申请内存大于128k时，调用mmap系统调用在堆与栈之间（称为文件映射区域）寻找空闲内存进行分配，并初始化为0  
> &emsp; 7.该两种方式分配的都是虚拟内存，在第一次访问虚拟地址空间时会发生缺页中断，操作系统此时才会分配物理内存并更新页表，建立映射关系  
>
> ##### 一个c++程序从文本到可执行文件的过程  
>
> &emsp; 1.预处理：删除并替换所有的#define，处理条件编译指令（"#if", "#endif", "else"等），处理"#include"预编译指令，删除注释等等，生成.ii文件  
> &emsp; 2.编译：词法分析，语法分析，语义分析，目标代码生成，目标代码优化，生成.s文件   
> &emsp; 3.汇编：将编译生成的文件转化为机器码，生成目标文件（.o文件或.obj文件）  
> &emsp; 4.链接：将多个目标文件和所需要的库连接形成可执行文件，生成.exe或.out文件   
>
> ##### 析构函数能否抛异常，为什么  
>
> &emsp; 1.c++标准指明析构函数不能，也不应该抛出异常。通常异常发生时，c++机制会调用析构函数释放异常对象的资源  
>
> &emsp; 2.若在析构函数中抛异常，则异常点之后的程序就不会执行，导致在异常点之后的资源释放不会执行，造成资源泄露  
>
> &emsp; 3.通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题  
>
> ##### 重载函数在编译阶段会怎么处理 
> &emsp; 1.编译时编译器根据函数的参数个数，参数类型和参数类型顺序等重新命名函数名  
> &emsp; 2.c语言关于函数编译后的命名与c++的有所不同，故在c++程序中使用编译过的C函数，需要使用加extern"c"  
>
> ##### new一个对象，delete两次会出现什么后果  
> &emsp; 1.该行为是未定义行为，主要看编译器的处理，有时候会出现运行报错并产生core文件（本人测试的结果），有时候并不产生报错  
> &emsp; 2.联想：在类的构造函数内动态申请内存（new）而并没有重写复制构造函数和赋值构造函数时（即使用编译器提供的函数），由于是浅复制（即两个指针同时指向同一块内存），会发生上述问题  
>
> ##### 构造函数是否能为虚函数  
> &emsp; 1.从使用角度看：虚函数的作用在于通过基类的指针或引用来调用派生类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过基类的指针或者引用去调用  
> &emsp; 2.从存储空间角度：虚函数是通过虚函数表来实现多态的，虚函数表实际是存储在对象的内存空间的。如果构造函数是虚函数，就需要通过虚函数表来调用，可是对象还没有实例化，无法找到虚函数表  
>
> ##### map与unordered_map的区别  
> &emsp; 1.map内部实现为红黑树，红黑树具有自动排序功能，故map内部元素是有序的，而unordered_map内部实现为哈希表，内部元素顺序是无序的  
> &emsp; 2.map操作的时间复杂度多为lgn，所需的空间较大，unordered_map查询效率高（O(1)），但哈希表的建立比较耗时，空间消耗小于map  
>
> ##### 能不能在头文件中定义全局变量
> &emsp; 因为变量只能被定义一次，包含了头文件的源文件，都将会定义同样的全局变量，造成冲突，所以，头文件中不能定义全局变量  
>
> ##### free()函数入参是一个void*指针，它是如何知道被指向的大小的  
> &emsp; malloc()函数分配内存时会分配一个额外的空间（头部）记录分配内存的大小，而free()函数执行时则向前偏移头部的大小取得需要free的空间的大小  
> #### 操作系统层面  
> ##### Linux下的锁  
> &emsp; 1.互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒  
> &emsp; 2.读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合  
> &emsp; 3.自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，循环检测锁的保持者是否释放，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源   
>
> ##### 系统如何将一个信号通知到进程  
> &emsp; 1.接收信号：当内核接收到信号后，将信号注册到对应进程的PCB中相关的数据结构中（未决信号的数据成员），并向进程发送一个中断，使其陷入内核态  
> &emsp; 2.检测信号：进程陷入内核后，会在两种情况下对信号进行检测。1.进程从内核态返回到用户态时。2.进程在内核态从睡眠状态被唤醒时    
> &emsp; 3.内核处理一个进程收到的信号的时机是在进程从内核态返回用户态时  
> &emsp; 4.执行自定义信号处理函数：把该函数的地址放在用户栈栈顶，进程从内核返回到用户态的时候，先弹出信号处理函数地址，于是就去执行信号处理函数了，然后再弹出，才是返回进入内核时的状态  
> &emsp; 5.信号的处理：内核在检测到信号时将进程返回到用户态执行相应的信号处理函数，随后返回到内核态检查其他信号，所有信号处理完后，进程返回到用户态并恢复现场  
> ##### fork创建的子进程继承了父进程打开的文件描述符，如何让这种继承不发生
> &emsp; 可以在打开文件的时候，设置FD_CLOSEXEC标志位，如果文件描述符中这个标志位置位，那么调用exec时会自动关闭对应的文件  
>
> ##### 写时复制  
>
>  &emsp; 1.创建子进程时，简单的为子进程复制父进程的副本，但大部分情况下子进程会调用exec函数加载新程序，导致空间以及时间的浪费  
>
>  &emsp; 2.写时复制：创建子进程时并不复制父进程的整个地址空间，而是复制父进程的页表，当有任意进程试图向该内存页写入，则引起缺页异常，此时才为进程分配新的内存空间  
>
> ##### 几个常见的信号 
>
> ##### 有关malloc(),calloc(),realloc()  
> &emsp; void* malloc(size_t, size):分配指定大小内存    
> &emsp; void* calloc(size_t number_of_elements, size_t element_size):分配个数(number_of_elements)乘以单位大小(element_size)的内存，并将其初始化为0  
> &emsp; void* realloc(void* existing_memory, size_t new_size):改变传入内存的大小(existing_memorry)  
#### 网络编程层面
> ##### 非阻塞模式下send()和recv()函数的返回值  
> &emsp; 1.返回值大于0：send()表示成功发送数据的byte，recv()表示成功接受数据的byte  
> &emsp; 2.返回值等于0：表示对端关闭（send()发送0字节数据，系统 并不会发送数据包）   
> &emsp; 3.返回值小于0：
> &emsp; &emsp; 1)：EINTR错误码：表示被信号中断  
> &emsp; &emsp; 2)：EAGAIN或EWOUDBLOCK错误码：表示TCP 窗口太小，数据暂时发不出去（send函数），当前内核缓冲区中无可读数据（recv函数）  
> &emsp; &emsp; 3)：其他情况：表示send()或recv()出错  
>
> #####  异步connnect的写法  
>
>   &emsp;1.创建socket，并将 socket 设置成非阻塞模式（调用socket()函数时加标记位或调用fctnl()/ioctl()）  
>
> &emsp; 2.调用connect()（此时会connect()会立即返回），但并不理会返回值  
>
> &emsp; 3.接着调用 select 函数，在指定的时间内判断该 socket 是否可写，如果可写说明连接成功，反之则认为连接失败  

#### 数据库层面

#### 多线程多进程层面  

#### GDB调试基本指令  
| 左对齐 | 右对齐 | 居中对齐 |
| :-----       | ----: | :----: |
| 单元格 | 单元格 | 单元格 |
| 单元格 | 单元格 | 单元格 |
