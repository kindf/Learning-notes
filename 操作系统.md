#### 进程和线程

##### 线程私有

> 线程栈，程序计数器，栈指针，使用的寄存器，统称线程上下文

##### 进程控制块（PCB）

>包括：进程状态，程序计数器（表示下条执行指令的地址），CPU寄存器，CPU调度信息，内存管理信息（页表或段表），I/O状态信息（分配给进程的I/O设备，打开的文件描述符等）

##### CPU调度算法

> 先到先服务调度算法（FCFS），最短作业优先调度算法（SJF），最短剩余时间优先调度算法（SRTF），轮转法（RR），多级队列调度算法，多级反馈队列调度算法

##### fork创建的子进程继承了父进程打开的文件描述符，如何让这种继承不发生

> 可以在打开文件的时候，设置FD_CLOSEXEC标志位，如果文件描述符中这个标志位置位，那么调用exec时会自动关闭对应的文件 

##### 僵尸进程

> 僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程（wait/waitpid），释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源（PID和对应的进程结构储存空间）
>
> 发现：ps -aux STAT=Z的进程
>
> 解决：捕捉SIGCHLD信号，在信号处理函数中调用wait()/waitpid()回收相关资源

##### 孤儿进程

> 在其父进程执行完成或被终止后仍继续运行的一类进程。这些孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作

##### 守护进程

##### 进程间通信机制

> 管道
>
> 共享内存
>
> 信号
>
> 信号量
>
> SOCKET

##### 常见的信号



##### 共享内存的实现

> 将同一物理内存的地址空间映射到不用进程的虚拟地址空间（内存映射区，位于堆与栈之间的空间）中,其大小在linux下通过SHMMAX参数定义(默认为32MB)
>
> 相关函数：shmget()，shmat()，shmctl()， shmdt()

##### 写时复制

> 传统上fork()创建进程是为子进程创建一个父进程地址空间的副本，复制属于父进程的页。由于大部分情况下子进程创建后会马上执行系统调用exec()，复制父进程地址空间并不是必须的。
>
> 调用fork()并不创建父进程的地址空间副本，而是和父进程共用，当任一进程需要对页进行写操作时，才创建共享页的副本
>
> vfork()（虚拟内存fork）：vfork()不使用写时复制，调用后会将父进程挂起（直到子进程调用exec()或_exit()），子进程使用父进程的地址空间，因此子进程修改地址空间的页在父进程重启时时可见的

##### 信号机制

> 发送：由内核将信号写入到目标进程或线程的信号队列（未决信号队列）中
>
> 接收：内核处理进程收到的信号是在进程从内核态返回用户态时（进程被信号唤醒或者正常调度重新获得CPU）
>
> 可靠信号：支持排队，不会丢失，信号值小于SIGRTMIN（34）

##### 死锁



#### 内存管理

##### MMU

> 内存管理单元，功能是将线性地址转换成物理地址

##### 虚拟内存

> 虚拟内存：将用户逻辑内存和物理内存分开，每个进程拥有自己独立的地址空间，这个空间被分割为多个块（称为页），当程序引用物理内存的地址空间时，由硬件做从虚拟地址到物理地址的映射，若不在物理内存则由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。

##### 分页

> 将物理内存分为固定大小的块（帧），将逻辑空间分为等大的块（页）。由CPU生成的每个地址以页号和页偏移表示。页表（存放在PCB中）储存每页所在物理内存的基地址，基地址和页偏移可以确定物理内存地址。
>
> 当访问的虚拟内存没有对应的物理内存时，操作系统出发缺页中断，将所缺的页从磁盘换入到物理内存并建立页表中的页和物理页的映射关系
>
> 快表：为提高虚拟地址到物理地址的映射速度，使用一种硬件缓冲（成为转换表缓冲区TLB）。TLB只包含小部分页表的条目，当发生寻址时先在TLB查找，查找失败才访问页表，同时将该条目添加到TLB中。
>
> 多级页表：32位的虚拟地址分为10位PT1域，10位的PT2域和12位的Offset（偏移量）。一级页表索引（PT1）二级页表，二级页表索引（PT2）物理地址，二级页表在实际访问时才创建，从而达到节省页表所占内存过大的问题。

##### 内存碎片

> 内部碎片：当程序申请n字节大小的空间，而系统没有合适大小的内存空间，只能分配稍大于n字节的空间时，多余的空间成为内部碎片（已经分配，属于特定进程）
>
> 外部碎片：频繁的分配与回收物理页面会导致大量的、连续且小的页面块夹杂在已分配的页面中间，就会产生外部碎片（没被分配出去，不属于任何进程）

##### 伙伴算法

> 将空闲内存分为若干块空间大小为1，2，4，8，...，1024，用链表连接起来，分配空间时从空闲的内存中搜索比申请的内存大的最小的内存块，如果这样的内存块存在，则将这块内存标记为“已用”，同时将该内存分配给应用程序。如果这样的内存不存在，则操作系统将寻找更大块的空闲内存，然后将这块内存平分成两部分，一部分返回给程序使用，另一部分作为空闲的内存块等待下一次被分配
>
> 伙伴算法是以产生内部碎片的代价来解决外部碎片的问题

##### slab算法

> 

#### 存储管理